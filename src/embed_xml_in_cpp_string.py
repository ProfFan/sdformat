# Copyright 2018 Open Source Robotics Foundation
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This is the program to take an input file containing a list of filenames,
# read the data from each of those files, and generate a C++ string that
# contains that data.  A single C++ file and header file are generated for
# each piece of data.  Here are some of the assumptions of this program:
#
# 1.  The directory that the output file resides in exists.
# 2.  The output file path is either absolute, or relative to the directory
#     in which this python script lives.
# 3.  The input file contains a list of filenames to read.
# 4.  The list of filenames in the input file is semi-colon separated.
# 5.  The previous point implies that the filenames cannot have semi-colons
#     themselves.
# 6.  The list of filenames in the input file is absolute, or relative to
#     the directory in which this python script lives.
# 7.  Each entry in the list of filenames is of the form:
#     start/path/<version>/<filename>.  The <version> portion will be used
#     to generate the namespace that each string lives in, and the filename
#     will be used as the name of the variable.

import sys

if len(sys.argv) != 4:
    print("Usage: %s <out_cc_file> <out_hh_file> <infile-list-of-filenames>")
    sys.exit(1)

out_cc_file = sys.argv[1]
out_hh_file = sys.argv[2]
infile = sys.argv[3]

with open(infile, 'r') as infp:
    data = infp.read()

filenames = data.split(';')
filenames.sort()

# First generate the C++ file.
with open(out_cc_file, 'w') as outfp:
    outfp.write("// Automatically generated by cmake; do not edit!\n\n")
    outfp.write("#include <string>\n\n")

    version_namespaces = []
    for f in filenames:
        splitpath = f.split('/')
        # We assume that the directory right above the file itself is the
        # version.  C++ namespaces cannot contain dots, so replace them with
        # underscores.
        version = splitpath[-2].replace('.', '_')
        # The namespace is the version of SDF we are currently looking at.
        if not version in version_namespaces:
            # If there is a previously opened namespace, close it.
            if version_namespaces:
                outfp.write("} // end namespace sdf_%s\n" % (version_namespaces[-1]))
            outfp.write("namespace sdf_%s {\n" % (version))
            version_namespaces.append(version)
        # We use the filename as the name of the variable.  C++ variable names
        # cannot contain dots, so replace them with underscores.
        varname = splitpath[-1].replace('.', '_')
        outfp.write("  std::string xml_%s =\n" % (varname))
        # For each line in the input file, we read it in, strip off any
        # trailing whitespace (including newlines), replace all double-quotes
        # with escaped double-quotes, then write it to the output file.
        with open(f, 'r') as infp:
            for line in infp.xreadlines():
                contents = line.rstrip().replace('"', '\\"')
                outfp.write('"%s"\n' % (contents))
        outfp.write(";\n\n")

    # Close the last namespace
    if version_namespaces:
        outfp.write("}  // end namespace sdf_%s\n" % (version))

# Now generate the header file
with open(out_hh_file, 'w') as outfp:
    outfp.write("#ifndef EMBEDDED_XML_HH_\n")
    outfp.write("#define EMBEDDED_XML_HH_\n\n")

    version_namespaces = []
    for f in filenames:
        splitpath = f.split('/')
        # We assume that the directory right above the file itself is the
        # version.  C++ namespaces cannot contain dots, so replace them with
        # underscores.
        version = splitpath[-2].replace('.', '_')
        # The namespace is the version of SDF we are currently looking at.
        if not version in version_namespaces:
            # If there is a previously opened namespace, close it.
            if version_namespaces:
                outfp.write("} // end namespace sdf_%s\n" % (version_namespaces[-1]))
            outfp.write("namespace sdf_%s {\n" % (version))
            version_namespaces.append(version)
        # We use the filename as the name of the variable.  C++ variable names
        # cannot contain dots, so replace them with underscores.
        varname = splitpath[-1].replace('.', '_')
        outfp.write("  extern std::string xml_%s;\n" % (varname))

    # Close the last namespace
    if version_namespaces:
        outfp.write("}  // end namespace sdf_%s\n" % (version))
    outfp.write("#endif\n")
