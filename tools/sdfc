#!/usr/bin/ruby

require "rexml/document"
require "optparse"

@@namespace = nil
@@path = "/home/nkoenig/work/robot_xml/rml/1.5"

# The license header for each generated file
@@license = <<-END
/*
 * Copyright 2013 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/
END

##################################################
# Base class for C++ Classes and Attributes
class Object
  class << self; attr_accessor :name end
  class << self; attr_accessor :description end
  class << self; attr_accessor :scope end

  ################################################
  # \brief Add a description. Descriptions come from the SDF element
  # <description>
  # \param[in] _elem The SDF description element.
  def addDescription(_elem)
    # Make sure the _elem has a valid description.
    if _elem && _elem.elements["description"] != nil &&
       _elem.elements["description"].text != nil
      # Format the description so that it doesn't exceed 40 characters 
      # in length, and store for later use.
      @description = _elem.elements["description"].text.gsub(
        /\n/,'').concat(' ').scan(/.{1,40}[\W]/)
    end
  end

  ################################################
  # \brief Print the description in Doxygen format
  # \param[in] _file The file into which the description is printed.
  # \param[in] _spaces Number of spaces to prepend to each line
  def printBrief(_file, _spaces)
    if @description
      size = 0
      char_limit = 40
 
      _file.printf("%*s/// \\brief %s\n", _spaces, "", @description[0])
  
      # Output remaining lines of the description.
      @description.drop(1).each do |line|
        _file.printf("%*s/// %s\n", _spaces, "", line)
      end
    end
  end
end

#################################################
# \brief An attribute in a Class
class Attribute < Object
  attr_accessor :type
  attr_accessor :required
  attr_accessor :noScoping
  attr_accessor :name
  attr_accessor :origName
  attr_accessor :scope

  ###############################################
  # \brief Constructor
  # \param[in] _type (string) The attribute data type.
  # \param[in] _name (string) Name of the attribute.
  # \param[in] _required (0,1,+,*) True if the attribute is expected to be
  # set.
  # \param[in] _scope (string) Namespace scoping string (string).
  def initialize(_type, _name,  _required, _scope)
    # Convert SDF typename to C typename.
    @type = self.convertType(_type)

    # Store the orignal name, used to retreive values from SDF XML.
    @origName =_name

    # Fix reserved word names.
    @name = self.fixReservedWord(_name)

    @required = _required
    @noScoping = false
    @scope = ""

    # Add scoping if the type is non-standard.
    if !self.isStdType
      @scope = _scope.empty? ? @@namespace + "::" : _scope + "::"
    elsif self.isSDFType
      @scope = "sdf::"
    end
  end

  ###############################################
  # \brief (string) Return the scoped attribute type.
  def scopedType
    return @scope + @type
  end

  ###############################################
  # \brief Use this function to fix C reserverd words
  # \param[in] _str (string) String to fix
  def fixReservedWord(_str)
    if _str == "static"
      return "_" + _str
    end
    return _str
  end

  ###############################################
  # \brief Convert an SDF XML typename to C type
  # \param[in] _type (string) Typename to convert.
  # \return (string) Usually the original _type, a capitalized
  # version of _type, or "std::string" 
  def convertType(_type)
    if !_type
      return _type
    end

    if _type == "pose" || _type == "color" || _type.include?("vector2i") ||
       _type.include?("vector2d") || _type.include?("vector3") ||
       _type == "quaternion" || _type == "time" || _type == "inertia"
      return _type.capitalize
    elsif _type == "string"
      return "std::string"
    else
      return _type
    end
  end

  ###############################################
  # \brief Return true if @type is a SDF type.
  # \return (bool) If @type is a standard SDF.
  def isSDFType()
   return @type == "Pose" || @type == "Color" ||
     @type == "Vector3" || @type == "Vector2i" ||
     @type == "Vector2d" || @type == "Quaternion" ||
     @type == "Time"
  end

  ###############################################
  # \brief Return true if @type is a standard type.
  # \return (bool) If @type is a standard SDF or C type.
  def isStdType()
   return self.isSDFType || @type == "std::string" ||
     @type == "int" || @type == "double" || @type == "float" ||
     @type == "bool" || @type == "char" || @type == "unsigned int"
  end

  ###############################################
  # \brief Print the accessor function implementations.
  # \param[in] _file File in which to print the function implementations.
  # \param[in] _namespace Scoped namespace to use when printing.
  def printAccessorImpl(_file, _namespace)
    if !@type || @type.empty?
      return
    end

    # Print functions for attributes that are single values.
    if @required == "0" || @required == "1"
      # Print "type Class::attribute()" accesor.
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("%s %s%s() const\n{\n", self.scopedType, _namespace, @name)
      _file.printf("  return this->%s_;\n", @name)
      _file.printf("}\n")

      # Print bool Class::has_attribute() accesor.
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("bool %shas_%s() const\n{\n", _namespace, @name)
      _file.printf("  return this->has_%s_;\n", @name)
      _file.printf("}\n")
    # Print functions for attributes that are a vector of values.
    else
      # Print "bool Class::has_attribute()" accesor.
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("bool %shas_%s() const\n{\n", _namespace, @name)
      _file.printf("  return !this->%s_.empty();\n", @name)
      _file.printf("}\n")

      # Print "type Class::attribute(index)" accesor.
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("%s %s%s(unsigned int _index) const\n{\n", self.scopedType,
                   _namespace, @name)
      _file.printf("  %s result;\n", self.scopedType);
      _file.printf("  if (_index < this->%s_.size())\n",@name)
      _file.printf("    result = this->%s_[_index];\n", @name)
      _file.printf("  else\n")
      _file.printf("    sdferr << \"Index of[\" << _index << \"] exceeds\"\n")
      _file.printf("      \"array size[\" << this->%s_.size() << \"]\";\n",
                   @name)
      _file.printf("  return result;\n")
      _file.printf("}\n")

      # Print "uint Class::attribute_size()" accesor.
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("unsigned int %s%s_size() const\n{\n",_namespace, @name)
      _file.printf("  return this->%s_.size();\n", @name)
      _file.printf("}\n")

      # Print "vector<type> Class::attribute()" accesor.
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("const std::vector<%s> &%s%s() const\n{\n",
                   self.scopedType, _namespace, @name)
      _file.printf("  return this->%s_;\n", @name)
      _file.printf("}\n")

      # The mutable accessors and setters are disabled. Put back in if they
      # are needed.
      # Print "vector<type> *Class::mutable_attribute()" accesor.
      # _file.printf("\n//////////////////////////////////////////////////\n")
      # _file.printf("std::vector<%s> *%smutable_%s()\n{\n", self.scopedType,
      #              _namespace, @name)
      # _file.printf("  return &(this->%s_);\n", @name)
      # _file.printf("}\n")
    end
  end

  ###############################################
  # \brief Print the accessor function definitions
  # \param[in] _file (file object) File in which to print the definitions.
  # \param[in] _spaces (int) Number of spaces to prepend to each line.
  # \param[in] _namespace (string) Scoped namespace to use when printing.
  def printAccessorDef(_file, _spaces, _namespace)
    if !@type || @type.empty?
      return
    end

    # Print functions for attributes that are single values.
    if @required == "0" || @required == "1"
      # Print "type Class::attribute()" accesor definition.
      _file.printf("%*s/// \\brief %s accessor\n", _spaces, "", @name)
      _file.printf("%*s/// \\return The value of %s\n", _spaces, "", @name)
      _file.printf("%*s/// \\sa set_%s\n", _spaces, "", @name)
      _file.printf("%*spublic: %s %s() const;\n\n", _spaces, "",
                   self.scopedType, @name)

      # Print "bool Class::has_attribute()" accesor definition.
      _file.printf("%*s/// \\brief %s Has \n", _spaces, "", @name)
      _file.printf("%*s/// \\return The ture if %s is set.\n",
                   _spaces, "", @name)
      _file.printf("%*spublic: bool has_%s() const;\n\n",
                   _spaces, "", @name)
    # Print functions for attributes that are vector of values.
    else
      # Print "bool Class::has_attribute()" accesor definition.
      _file.printf("%*s/// \\brief %s Has \n", _spaces, "", @name)
      _file.printf("%*s/// \\return The ture if %s is not empty.\n",
                   _spaces, "", @name)
      _file.printf("%*spublic: bool has_%s() const;\n\n",
                   _spaces, "", @name)

      # Print "type Class::attribute(index)" accesor definition.
      _file.printf("%*s/// \\brief %s accessor\n", _spaces, "", @name)
      _file.printf("%*s/// \\return The value of %s\n", _spaces, "", @name)
      _file.printf("%*s/// \\param[in] _index Index into %s\n",
                   _spaces, "", @name)
      _file.printf("%*s/// \\sa set_%s\n", _spaces, "", @name)
      _file.printf("%*spublic: %s %s(unsigned int _index) const;\n\n",
                   _spaces, "", self.scopedType, @name)

      # Print "uint Class::attribute_size()" accesor.
      _file.printf("%*s/// \\brief Get size of %s\n", _spaces, "", @name)
      _file.printf("%*spublic: unsigned int %s_size() const;\n\n",
                   _spaces, "", @name)

      # Print "vector<type> Class::attribute()" accesor.
      _file.printf("%*s/// \\brief Get %s vector\n", _spaces, "", @name)
      _file.printf("%*s/// \\return Immutable %s vector\n", _spaces, "", @name)
      _file.printf("%*spublic: const std::vector<%s> &%s() const;\n\n",
                   _spaces, "", self.scopedType, @name)

      # The mutable accessors and setters are disabled. Put back in if they
      # are needed.
      # _file.printf("%*s/// \\brief Get mutable %s vector\n",
      #              _spaces, "", @name)
      # _file.printf("%*s/// \\return Mutable %s vector\n",
      #              _spaces, "", @name)
      # _file.printf("%*spublic: std::vector<%s> *mutable_%s();\n\n",
      #              _spaces, "", @type, @name)
    end
  end

  ###############################################
  # \brief Print setter function implementations.
  # \param[in] _file (file object) File in which to print function
  # implementations.
  # \param[in] _namespace (string) Namespace to use when printing.
  def printSetterImpl(_file, _namespace)
    if !@type || @type.empty?
      return
    end

    # Print functions for attributes that are single values.
    if @required == "0" || @required == "1"
      # The mutable accessors and setters are disabled. Put back in if they
      # are needed.
      # _file.printf("\n//////////////////////////////////////////////////\n")
      # _file.printf("%s *%smutable_%s()\n{\n", self.scopedType,
      #              _namespace, @name)
      # _file.printf("  this->has_%s_ = true;\n", @name)
      # _file.printf("  return &(this->%s_);\n", @name)
      # _file.printf("}\n")

      # Print "void Class::set_attribute(type)" function
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("void %sset_%s(const %s &_v)\n{\n",
                   _namespace, @name, self.scopedType)
      _file.printf("  this->has_%s_ = true;\n", @name)
      _file.printf("  this->%s_ = _v;\n", @name)
      _file.printf("}\n")
    # Print functions for attributes that are a vector of values.
    else
      # The mutable accessors and setters are disabled. Put back in if they
      # are needed.
      # _file.printf("\n//////////////////////////////////////////////////\n")
      # _file.printf("%s *%smutable_%s(unsigned int _index)\n{\n",
      #        self.scopedType, _namespace, @name)
      # _file.printf("  %s *result = NULL;\n", self.scopedType)
      # _file.printf("  if (_index < this->%s_.size())\n",@name)
      # _file.printf("    result = &(this->%s_[_index]);\n", @name)
      # _file.printf("  else\n")
      # _file.printf("    sdferr << \"Index of[\" << _index << \"] exceeds\"\n")
      # _file.printf("      \"array size[\" << this->%s_.size() << \"]\";\n",
      #              @name)
      # _file.printf("  return result;\n")
      # _file.printf("}\n")

      # Print "type *Class::add_attribute()" function
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("%s *%sadd_%s()\n{\n", self.scopedType, _namespace, @name)
      _file.printf("  this->%s_.push_back(%s());\n", @name, self.scopedType)
      _file.printf("  return &(this->%s_.back());\n", @name)
      _file.printf("}\n")

      # Print "void Class::set_attribute(type, index)" function
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("void %sset_%s(const %s &_v, unsigned int _index)\n{\n",
             _namespace, @name, self.scopedType)
      _file.printf("  if (_index < this->%s_.size())\n",@name)
      _file.printf("    this->%s_[_index] = _v;\n", @name)
      _file.printf("  else\n")
      _file.printf("    sdferr << \"Index of[\" << _index << \"] exceeds\"\n")
      _file.printf("      \"array size[\" << this->%s_.size() << \"]\";\n",
                   @name)
      _file.printf("}\n")

      # Print "void Class::clear_attribute()" function
      _file.printf("\n//////////////////////////////////////////////////\n")
      _file.printf("void %sclear_%s()\n{\n",_namespace, @name)
      _file.printf("  this->%s_.clear();\n", @name)
      _file.printf("}\n")
    end
  end

  ###############################################
  # \brief Print setter function definitions
  # \param[in] _file (file object) File in which to print setter
  # definitions.
  # \param[in] _spaces (int) Numbe of spaces to prepend to each line.
  def printSetterDef(_file, _spaces)
    if !@type || @type.empty?
      return
    end

    # Print functions for attributes that are single values.
    if @required == "0" || @required == "1"
      # The mutable accessors and setters are disabled. Put back in if they
      # are needed.
      # _file.printf("%*s/// \\brief Get mutable pointer to %s\n",
      #              _spaces, "", @name)
      # _file.printf("%*s/// \\sa set_%s\n", _spaces, "", @name)
      # _file.printf("%*spublic: %s *mutable_%s();\n\n",
      #        _spaces, "", @type, @name)

      # Print "void Class::set_attribute(type)" function
      _file.printf("%*s/// \\brief Set %s\n", _spaces, "", @name)
      _file.printf("%*s/// \\param[in] _v New value for %s\n",
                   _spaces, "", @name)
      _file.printf("%*s/// \\sa mutable_%s\n", _spaces, "", @name)
      _file.printf("%*spublic: void set_%s(const %s &_v);\n\n",
             _spaces, "", @name, self.scopedType)
    # Print functions for attributes that are a vector of values.
    else
      # The mutable accessors and setters are disabled. Put back in if they
      # are needed.
      # _file.printf("%*s/// \\brief Get mutable pointer to %s\n",
      #              _spaces, "", @name)
      # _file.printf("%*s/// \\param[in] _index Index into %s\n",
      #              _spaces, "", @name)
      # _file.printf("%*s/// \\sa set_%s\n", _spaces, "", @name)
      # _file.printf("%*spublic: %s *mutable_%s(unsigned int _index);\n\n",
      #        _spaces, "", @type, @name)

      # Print "type *Class::add_attribute()" function
      _file.printf("%*s/// \\brief Add to %s\n", _spaces, "", @name)
      _file.printf("%*spublic: %s *add_%s();\n\n", _spaces, "",
                   self.scopedType, @name)

      # Print "void Class::set_attribute(type, index)" function
      _file.printf("%*s/// \\brief Set %s\n", _spaces, "", @name)
      _file.printf("%*s/// \\param[in] _v New value for %s\n", _spaces,
                   "", @name)
      _file.printf("%*s/// \\param[in] _index Index into %s\n", _spaces,
                   "", @name)
      _file.printf("%*s/// \\sa mutable_%s\n", _spaces, "", @name)
      _file.printf(
        "%*spublic: void set_%s(const %s &_v, unsigned int _index);\n\n",
        _spaces, "", @name, self.scopedType)

      # Print "void Class::clear_attribute()" function
      _file.printf("%*s/// \\brief Clear %s\n", _spaces, "", @name)
      _file.printf("%*spublic: void clear_%s();\n\n", _spaces, "", @name)
    end
  end

  ###############################################
  # \brief Print the definition of the attribute
  # \param[in] _file (file object) File in which attribute definitions are
  # printed.
  # \param[in] _spaces (int) Number of spaces to prepend to each line.
  # \param[in] _namespace (string) Namespace used for printing.
  def printDef(_file, _spaces, _namespace)

    # Output the doxygen comments.
    self.printBrief(_file, _spaces)

    # Output "private:  " 
    _file.printf("%*sprivate: ", _spaces, "")

    # Output the attribute definition.
    if @required == "0" || @required == "1"
      _file.printf("%s %s_;\n\n", self.scopedType , @name)

      _file.printf("%*sprivate: bool has_%s_;\n\n", _spaces, "", @name)
    else
      _file.printf("std::vector<%s> %s_;\n\n", self.scopedType , @name)
    end
  end
end

###############################################
# \brief Aggregate information about a C++ class from SDF XML.
class Class < Object
  @includes = []
  @attributes = []
  @classes = []
  @keyValueMap = []
  attr_accessor :nameCamel
  attr_accessor :name
  attr_accessor :scope
  attr_accessor :headerFile

  ###############################################
  # \brief Constructor
  # \param[in] _name (string) Name of the class.
  # \param[in] _scope (string) Namespace scope of the class.
  def initialize(_name, _scope, _headerFile)
    @includes = []
    @attributes = []
    @classes = []
    @keyValueMap = []

    # Convert the name to camel case
    @nameCamel = _name.split('_').map{|e| e.capitalize}.join('_')
    @name = _name

    # Apply appropriate scoping.
    @scope = _scope.empty? ? @@namespace + "::" : _scope + "::"

    if _headerFile.nil?
      @headerFile = @name;
    else
      @headerFile = _headerFile;
    end
  end

  ###############################################
  # Add a subclass
  def addClass(_elem)
    cls = Class.new(_elem.attributes["name"], @scope + @nameCamel, nil)
    cls.addDescription(_elem)
    @classes.push(cls)

    attr = Attribute.new(cls.nameCamel, cls.name.downcase,
                         _elem.attributes["required"], @scope + @nameCamel)

    attr.addDescription(_elem)
    @attributes.push(attr)

    return cls
  end

  ###############################################
  # \brief Add an <include> to the class
  def addInclude(_elem)
    inc = _elem.attributes["filename"].sub(
      "\.sdf","")

    path = File.join(@@path, _elem.attributes["filename"])
    doc = REXML::Document.new File.new(path)
    incElemName = doc.root.attributes['name']
    incElemName = incElemName.split('_').map{|e| e.capitalize}.join('_')
    
    attr = Attribute.new(incElemName, inc,
                         _elem.attributes["required"], "")
    attr.noScoping = true

    @attributes.push(attr)
   
    @includes.push(inc)
  end

  ###############################################
  # \brief Add an attribute to the class
  def addAttribute(_elem)
    attr = Attribute.new(_elem.attributes["type"], _elem.attributes["name"],
                         _elem.attributes["required"], @scope + @nameCamel)

    attr.addDescription(_elem)
    @attributes.push(attr)
  end

  ###############################################
  # \brief Print the class definition.
  # \param[in] _file File that receives definition.
  # \param[in] _spaces Number of spaces to use as formating.
  def printDef(_file, _spaces, _scope)
    self.printBrief(_file, _spaces)
    if _spaces == 2
      _file.printf("%*sclass %s\n", _spaces, "", @nameCamel)
    else
      _file.printf("%*spublic: class %s\n", _spaces, "", @nameCamel)
    end
    _file.printf("%*s{\n", _spaces, "")

    _file.printf("%*s  /// \\brief Constructor.\n", _spaces, "")
    _file.printf("%*s  public: %s();\n\n", _spaces, "", @nameCamel)

    _file.printf("%*s  /// \\brief Destructor.\n", _spaces, "")
    _file.printf("%*s  public: virtual ~%s();\n\n", _spaces, "", @nameCamel)

    # Print child class definitions.
    @classes.each do |cls|
      cls.printDef(_file, _spaces+2, _scope + @nameCamel + "::")
    end

    # Print attribute accessor definitions.
    @attributes.each do |attr|
      attr.printAccessorDef(_file, _spaces+2, _scope + @nameCamel+"::")
    end

    # Print attribute setter definitions.
    @attributes.each do |attr|
      attr.printSetterDef(_file, _spaces+2)
    end

    # Print out class operator= function definition
    _file.printf("%*s/// \\brief Equal operator %s.\n",
                 _spaces+2, "", @name)
    _file.printf("%*s/// \\param[in] _v Value to copy.\n", _spaces+2, "")
    _file.printf("%*s/// \\return Reference to this.\n", _spaces+2, "")
    _file.printf("%*spublic: %s &operator=(const %s &_v);\n\n",
           _spaces+2, "", @nameCamel, @nameCamel)

    # Print out set from SDFPtr function definition
    _file.printf("%*s/// \\brief Set from sdf::ElementPtr\n", _spaces+2, "")
    _file.printf("%*s/// \\param[in] _sdf sdf::ElementPtr.\n", _spaces+2, "")
    _file.printf("%*spublic: bool SetFromXML(const sdf::ElementPtr _sdf);\n\n",
           _spaces+2, "")

    streamV = "_v"
    if @attributes.empty?
      streamV = "/*_v*/"
    end

    # Stream output operator 
    _file.printf("%*s/// \\brief Stream insertion operator.\n", _spaces+2, "")
    _file.printf("%*s/// \\param[in] _o Output stream.\n", _spaces+2, "")
    _file.printf("%*s/// \\param[in] _v Object to output.\n", _spaces+2, "")
    _file.printf("%*s/// \\return The stream.\n", _spaces+2, "")
    _file.printf("%*spublic: std::string DebugString(int _spaces=0);\n\n",
                 _spaces+2, "")


    # Print property map definitions.
    @keyValueMap.each do |iter|
      _file.printf("%*spublic: sdf::PropertyMap %s;\n\n",
                   _spaces+2, "", iter)
    end

    # Print attribute definitions.
    @attributes.each do |attr|
      attr.printDef(_file, _spaces+2, _scope + @nameCamel + "::")
    end

    _file.printf("%*s};\n", _spaces, "")
  end

  ###############################################
  # \brief Print the implementation of the class
  def printImpl(_file, _spaces, _scope)
    @classes.each do |cls|
      cls.printImpl(_file, _spaces, _scope + @nameCamel + "::")
    end

    # Print the class constructor
    _file.printf("\n//////////////////////////////////////////////////\n")
    _file.printf("%s::%s()", _scope + @nameCamel, @nameCamel)

    inits = ""
    i = 0
    @attributes.each do |attr|
      if attr.required == "0" || attr.required == "1"
        inits += i > 0 ? "\n  ," : "\n   "
        inits += "has_#{attr.name}_(false)"
        i += 1
      end
    end

    if !inits.empty?
      _file.printf(" :%s", inits)
    end
    _file.printf("\n")


    _file.printf("{\n")
    _file.printf("}\n")

    # Print the class destructor
    _file.printf("\n//////////////////////////////////////////////////\n")
    _file.printf("%s::~%s()\n{\n", _scope + @nameCamel, @nameCamel)
    _file.printf("}\n")

    @attributes.each do |attr|
      attr.printAccessorImpl(_file, _scope + @nameCamel+"::")
      attr.printSetterImpl(_file, _scope + @nameCamel+"::")
    end

    # Print out class operator= function implementation.
    value = "&_v"
    sdfValue = "_sdf"
    if @attributes.length() == 0 && @classes.length() == 0
      value = "&/*_v*/"
    sdfValue = "/*_sdf*/"
    end
    _file.printf("\n//////////////////////////////////////////////////\n")
    _file.printf("%s &%s::operator=(const %s %s)\n{\n", _scope + @nameCamel,
                 _scope+@nameCamel, _scope + @nameCamel, value)
    @attributes.each do |attr|
      _file.printf("  this->%s_ = _v.%s_;\n", attr.name, attr.name)
    end

    @classes.each do |cls|
      _file.printf("  this->%s_ = _v.%s_;\n", cls.name, cls.name)
    end
    _file.printf("  return *this;\n")
    _file.printf("}\n")


    # Print SetFromXML function implementation.
    _file.printf("\n//////////////////////////////////////////////////\n")
    _file.printf("bool %s::SetFromXML(const sdf::ElementPtr %s)\n{\n",
                 _scope+@nameCamel, sdfValue)

    @attributes.each do |attr|
      _file.printf("  if (_sdf->HasElement(\"%s\") ||", attr.origName)
      _file.printf("      _sdf->HasAttribute(\"%s\"))\n", attr.origName)
      _file.printf("  {\n")
      if (attr.required == "0" || attr.required == "1")
        if attr.isStdType()
          _file.printf("    this->set_%s(_sdf->Get<%s>(\"%s\"));\n",
                       attr.name, attr.scopedType, attr.origName)
        else
          _file.printf("    this->%s_.SetFromXML(_sdf->GetElement(\"%s\"));\n",
                       attr.name, attr.origName)
          _file.printf("    this->has_%s_ = true;\n", attr.name);
        end
      else
        _file.printf("  this->%s_.clear();\n", attr.name)
        _file.printf("  for (sdf::ElementPtr iter = _sdf->GetElement(\"%s\");",
                     attr.origName)
        _file.printf("\n       iter != NULL;")
        _file.printf(" iter = iter->GetNextElement(\"%s\"))\n", attr.origName)
        _file.printf("  {\n")

        _file.printf("    %s attr;\n", attr.scopedType)
        if attr.isStdType()
          _file.printf("    attr = iter->Get<%s>();\n", attr.scopedType)
        else
          _file.printf("    attr.SetFromXML(iter);\n")
        end

        _file.printf("    this->%s_.push_back(attr);\n", attr.name)
        _file.printf("  }\n\n")
      end
      _file.printf("  }\n")
    end

    _file.printf("  return true;\n")
    _file.printf("}\n")

    # Print DebugString function implementation.
    _file.printf("\n//////////////////////////////////////////////////\n")
    _file.printf("std::string %s::DebugString(int _spaces)\n{\n", 
                 _scope+@nameCamel)
    _file.printf("  std::ostringstream out;\n")
    _file.printf("  std::string space(_spaces, ' ');\n")

    _file.printf("  out << \"%s {\" << std::endl;\n" , @nameCamel)

    @attributes.each do |attr|
      if (attr.required == "0" || attr.required == "1")
        if attr.isStdType()
          _file.printf(
            "  if (this->has_%s())\n", attr.name)
          _file.printf("  {\n")

          _file.printf(
            "    out << space << \"  %s: \" << this->%s_ << std::endl;\n",
            attr.name, attr.name)
          _file.printf("  }\n")
        else
          _file.printf("  if (this->has_%s())\n", attr.name)
          _file.printf("  {\n")
          _file.printf("    out << space << \"  %s: \" \n", attr.name)
          _file.printf("        << this->%s_.DebugString(_spaces+2);\n", attr.name)
          _file.printf("  }\n")
        end
      else
        _file.printf("  for (size_t i = 0; i < this->%s_.size(); ++i)\n",
                     attr.name)
        _file.printf("  {\n")
        _file.printf("    out << space << \"  %s[\" << i << \"] : \"\n",
                     attr.name)

        if attr.isStdType()
          _file.printf("        << this->%s_[i] << std::endl;\n", attr.name)
        else
          _file.printf("        << this->%s_[i].DebugString(_spaces+2);\n", attr.name)
        end
        _file.printf("  }\n\n")
      end
    end
    _file.printf("  out << space << \"}\" << std::endl;\n", @nameCamel)
    _file.printf("  return out.str();\n")
    _file.printf("}\n")

  end

  ###############################################
  # \brief Print includes from SDF description
  def getIncludes()
    result = []
    @includes.each do |include|
      result.push(include)
      #result.push(include.split('_').map{|e| e.capitalize}.join)
    end

    @classes.each do |cls|
      result.concat(cls.getIncludes()).uniq!
    end

    return result
  end

  ###############################################
  # \brief Print the header
  def printHeader(_file)
    _file.print(@@license)
    _file.printf("#ifndef _%s_%s_\n", @@namespace.upcase, @name.upcase)
    _file.printf("#define _%s_%s_\n\n", @@namespace.upcase, @name.upcase)

    _file.printf("#include <string>\n")
    _file.printf("#include <vector>\n")
    _file.printf("#include <sdf/Types.hh>\n")

    self.getIncludes().each do |include|
      _file.printf("#include \"%s.hh\"\n", include)
    end

    _file.printf("\n")

    spaces = 2

    _file.printf("namespace #{@@namespace}\n{\n")
    self.printDef(_file, spaces, "")
    _file.printf("}\n")
    _file.printf("#endif\n")
  end

  ###############################################
  # \brief Print the source file
  def printSource(_file)
    _file.print(@@license)
    _file.printf("#include <sdf/sdf.hh>\n")
    _file.printf("#include \"%s.hh\"\n", @headerFile)

    spaces = 0
    _file.printf("namespace #{@@namespace}\n{\n")
    self.printImpl(_file, spaces, "")
    _file.printf("}")
  end

  ###############################################
  # \brief Parse SDF definition.
  def parse(elem)
    if elem.get_elements("element").size > 0 ||
       elem.get_elements("attribute").size > 0 ||
       elem.get_elements("include").size > 0
      cls = self.addClass(elem)

      elem.elements.each("element") do |child|
        if child.attributes["copy_data"] == nil
          cls.parse(child)
        else
          @keyValueMap.push(child.attributes["name"])
        end
      end

      elem.elements.each("attribute") do |child|
        cls.addAttribute(child)
      end

      elem.elements.each("include") do |child|
        cls.addInclude(child)
      end

    else
      if elem.attributes["copy_data"] != nil
        @keyValueMap.push(elem.attributes["name"])
      else
        self.addAttribute(elem)
      end
    end
  end
end

infile = nil
outdir = nil

opt_parser = OptionParser.new do |o|
  o.on("-i", "--in [path]", String,
       "SDF file to compile") {|path| infile = path}
  o.on("-o", "--out [path]", String,
       "Output directory for source and header files") {|path| outdir = path}
  o.on("-n", "--name [name_space]", String,
       "Namespace for generated files") {|name_space| @@namespace = name_space}
  o.on("-h", "--help", "Display this help message") do
    puts opt_parser
    exit
  end
end
opt_parser.parse!

if infile.nil?
  puts "Missing option -i."
  exit
elsif !File.exists?(infile)
  puts "Input file[#{infile}] does not exist\n"
  exit
end

if outdir.nil?
  puts "Missing output directory, option -o."
  exit
elsif !Dir.exists?(outdir)
  Dir.mkdir(outdir)
end

if @@namespace.nil?
  puts "Missing option -n."
  exit
end

#sourceCMake = File.open(outdir + "CMakeLists.txt", "w")
#sourceCMake.printf("APPEND_TO_CACHED_LIST (dom_sources \"dom_sources\"\n")

#headerCMake = File.open(outdir + "CMakeLists.txt", "w")
#headerCMake.printf("include (${sdf_cmake_dir}/SDFUtils.cmake)\n")
#headerCMake.printf("set (headers\n")

#Dir.glob(File.join(indir,"*.sdf")) do |item|
doc = REXML::Document.new File.new(infile)

spaces = 2
doc.elements.each_with_index("element") do |elem, i|
  cls = Class.new(elem.attributes["name"], "",
                  infile.split("/").last.sub("\.sdf",""))
  cls.addDescription(elem)

  elem.elements.each("element") do |child|
    cls.parse(child)
  end

  elem.elements.each("attribute") do |child|
    cls.addAttribute(child)
  end

  elem.elements.each("include") do |child|
    cls.addInclude(child)
  end

  out_header = infile.split("/").last.sub("\.sdf","\.hh")
  out_source = infile.split("/").last.sub("\.sdf","\.cc")

  # Print header file 
  file = File.open(File.join(outdir, out_header), "w")
  cls.printHeader(file)
  file.close()

  # Print source file 
  file = File.open(File.join(outdir, out_source), "w")
  cls.printSource(file)
  file.close()

  #sourceCMake.printf("  %s.cc\n", cls.nameCamel)
  #headerCMake.printf("  %s.hh\n", cls.nameCamel)
end
#end

#sourceCMake.printf(")\n")
#sourceCMake.printf("sdf_add_library(sdfdom ${sources})\n")
#sourceCMake.printf("target_link_libraries(sdfdom sdformat)\n")
#sourceCMake.printf("sdf_install_library(sdfdom)")
#sourceCMake.close

#headerCMake.printf(")\n")
#headerCMake.printf("sdf_install_includes(\"dom\" ${headers})")
#headerCMake.close
